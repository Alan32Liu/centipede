// Copyright 2023 The Centipede Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This library defines the concepts "fuzzing feature" and "feature domain".
// It is used by Centipede, and it can be used by fuzz runners to
// define their features in a way most friendly to Centipede.
// Fuzz runners do not have to use this file nor to obey the rules defined here.
// But using this file and following its rules is the simplest way if you want
// Centipede to understand the details about the features generated by the
// runner.

#ifndef THIRD_PARTY_CENTIPEDE_CONCURRENT_BYTESET_H_
#define THIRD_PARTY_CENTIPEDE_CONCURRENT_BYTESET_H_

#include <climits>
#include <cstddef>
#include <cstdint>
#include <functional>

// WARNING!!!: Be very careful with what STL headers or other dependencies you
// add here. This header needs to remain mostly bare-bones so that we can
// include it into runner.

namespace centipede {

// TODO(kcc): replace the standalone ForEachNonZeroByte with code from here.
// TODO(kcc): ConcurrentByteSet is an unoptimized single-layer byte set.
// Implement multi-layer byte set(s).

// A fixed-size byte set containing kSize bytes, kSize must be a multiple of 64.
// Set() can be called concurrently with another Set(), other uses should be
// synchronized externally.
// Intended usage is to call ForEachNonZeroByte() from one thread.
template <size_t kSize>
class ConcurrentByteSet {
 public:
  static_assert((kSize % 64) == 0);

  // Constructs an empty byte set.
  ConcurrentByteSet() = default;

  // Clears the set.
  void clear() { memset(bytes_, 0, sizeof(bytes_)); }

  // Sets element `idx` to `value`. `idx` must be <= kSize.
  // Can be called concurrently.
  void Set(size_t idx, uint8_t value) {
    if (idx >= kSize) __builtin_trap();
    __atomic_store_n(&bytes_[idx], value, __ATOMIC_RELAXED);
  }

  // Calls `action(index, value)` for every {index,value} of a non-zero byte in
  // the set, then sets all those bytes to zero.
  void ForEachNonZeroByte(const std::function<void(size_t, uint8_t)> &action) {
    using word_t = uintptr_t;
    constexpr size_t kWordSize = sizeof(word_t);
    // Iterate one word at a time.
    for (uint8_t *ptr = &bytes_[0], *end = &bytes_[kSize]; ptr < end;
         ptr += kWordSize) {
      word_t word;
      __builtin_memcpy(&word, ptr, kWordSize);
      if (!word) continue;
      __builtin_memset(ptr, 0, kWordSize);
      // This loop assumes little-endianness. (Tests will break on big-endian).
      for (size_t pos = 0; pos < kWordSize; pos++) {
        uint8_t value = word >> (pos * CHAR_BIT);  // lowest byte is taken.
        if (value) action(ptr - &bytes_[0] + pos, value);
      }
    }
  }

 private:
  uint8_t bytes_[kSize] __attribute__((aligned(64))) = {};
};

}  // namespace centipede

#endif  // THIRD_PARTY_CENTIPEDE_CONCURRENT_BYTESET_H_
