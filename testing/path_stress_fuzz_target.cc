// Copyright 2022 The Centipede Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A fuzz target used for testing a fuzzing engine.
// It aborts on input "1234" and several others.
// The code here has very little control flow, but an exponential number of
// call paths. And input like "1234" triggers a call sequence F1->F2->F3->F4.
// The value `sink` generated by these functions represents the call sequence.
// The goal of this test is to verify that "bounded-path" features work.
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

static volatile uint64_t sink;

using Func = void (*)(const uint8_t *data, size_t size, size_t pos);

// Forward decl.
Func GetCallbackByIndex(size_t idx);

// Define 16 different functions with similar body that call each other.
// The functions modify `sink` in different ways.
#define FUNC(idx)                                             \
  void F##idx(const uint8_t *data, size_t size, size_t pos) { \
    sink = sink * 16 + idx;                                   \
    if (pos + 1 == size) return;                              \
    GetCallbackByIndex(data[pos + 1])(data, size, pos + 1);   \
  }

FUNC(0)
FUNC(1)
FUNC(2)
FUNC(3)
FUNC(4)
FUNC(5)
FUNC(6)
FUNC(7)
FUNC(8)
FUNC(9)
FUNC(10)
FUNC(11)
FUNC(12)
FUNC(13)
FUNC(14)
FUNC(15)

// All functions in an array.
static Func table[16] = {F0, F1, F2,  F3,  F4,  F5,  F6,  F7,
                         F8, F9, F10, F11, F12, F13, F14, F15};

// Gets one of F0-F15 based on `idx`.
Func GetCallbackByIndex(size_t idx) { return table[idx % 16]; }

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  if (size == 0 || size > 4) return 0;
  sink = 0;
  GetCallbackByIndex(data[0])(data, size, 0);
  if (sink == 0x1234) {
    fprintf(stderr, "BINGO\n");
    abort();
  }
  return 0;
}
